---
alwaysApply: true
---

## ✅ 最佳实践

- **跨端兼容**:
  - 优先使用 Taro 提供的跨端组件和 API。
  - 需要条件编译时，使用 `process.env.TARO_ENV` 变量。
- **性能优化**:
  - **分包加载**: 对非核心页面和资源使用 `subPackages` 配置。
  - **图片资源**: 统一存放于 `src/assets` 并压缩。
  - **虚拟列表**: 对于长列表，考虑使用虚拟列表技术。
  - **包体积分析**: 使用 `webpack-bundle-analyzer` (`npm run analyze:weapp`) 定期分析项目打包后的体积，识别并优化过大的模块。
- **自定义导航栏适配**: 在实现自定义顶部导航栏时，必须通过 `Taro.getWindowInfo()` 和 `Taro.getMenuButtonBoundingClientRect()` API 精确计算导航栏尺寸，并封装为统一的 `<CustomHeader>` 组件。所有使用该组件的页面，必须在 `index.config.ts` 中设置 `navigationStyle: 'custom'`。
- **⚠️ 页面布局核心规范 (强制性)**
  所有页面**必须**遵循以下“防内容遮挡”的顶级布局结构，这是一个从实践中总结的、不可违反的硬性规定。

  ```tsx
  <View style={{ display: "flex", flexDirection: "column", height: "100vh" }}>
    {/* 1. 顶部必须是统一的自定义导航栏 */}
    <CustomHeader />
    {/* 2. 页面主体内容必须包裹在这个 View 和 ScrollView 中 */}
    <View style={{ flex: 1, overflow: "hidden" }}>
      <ScrollView scrollY style={{ height: "100%" }}>
        {/* 页面所有可滚动内容都放在这里 */}
      </ScrollView>
    </View>
  </View>
  ```

  在 `index.config.ts` 中，也**必须**设置 `navigationStyle: 'custom'`。

- **⚠️ 右上角安全区域规范 (强制性)**
  **禁止**在自定义导航栏 (`<CustomHeader>`) 的右上角区域放置任何可交互的控件。该区域在异形屏手机上极易与系统状态栏重叠。所有页面级别的主操作按钮，**必须**统一放置在页面底部的操作栏中。

- **代码检查**: 集成 ESLint, Prettier 和 Stylelint, 并配置 `husky` 和 `lint-staged` 在 `pre-commit` 钩子中自动检查和格式化暂存区代码。

## Git 规范

- **分支模型**: 采用 `Git Flow`。
- **Commit Message**: 遵循 `Angular` 提交规范 (`<type>(<scope>): <subject>`)。
- **自动化规范**:
  - **Commitizen**: 使用 `npm run commit` 来规范化提交信息。
  - **Husky + commitlint**: 在 `commit-msg` 钩子中自动校验提交信息。
  - **Husky + lint-staged**: 在 `pre-commit` 钩子中自动执行代码检查和格式化。

## 数据管理 (State Management)

- **状态管理库**: 项目选用 `Redux Toolkit (RTK)`。
- **目录结构**:
  - `src/store/slices`: 存放各业务模块的 `slice.ts` 文件。
  - `src/store/index.ts`: 组合 `slice` 并创建 Store。
- **数据持久化**: 对于用户 Token 等数据，使用 `redux-persist` 配合 `Taro.setStorage` 进行处理。
- **接口请求**: 在 `src/services` 目录中统一管理 API 请求，返回的数据通过 `createAsyncThunk` 更新到 `store`。

## 📡 API 对接工作流

为了保证与后端接口的高效、规范对接，所有涉及网络请求的代码都必须遵循以下**强制性规范**：

1.  **第一步：定义类型 (Types)** - 在 `src/types/api/` 目录下为模块创建或更新类型定义文件。
2.  **第二步：创建或更新 API 服务 (Service)** - 在 `src/services/api/` 目录下创建或更新对应的服务文件。所有请求**必须**使用 `src/services/request.ts` 中导出的 `http` 对象。
3.  **第三步：创建或更新 Redux Thunk (Slice)** - 在 `src/store/slices/` 中使用 `createAsyncThunk` 创建异步 action。
4.  **第四步：组件中使用** - 通过 `useDispatch` 派发 action，通过 `useSelector` 获取数据。

### 🔗 网络请求规范

- **统一封装**: 在 `src/services/request.ts` 中封装 `Taro.request`，统一处理请求头、错误等。
- **加载提示 (Loading)**: 默认**不显示**全局加载提示。对于需要强制用户等待的长时间操作，可通过在请求头中设置 `'X-Show-Loading': true` 来手动开启。
- **API 管理**: 在 `src/services/api/` 目录下按模块统一管理所有接口。
- **路径别名**: 在 `config/index.ts` 中配置 `@` 作为 `src` 目录的别名。

## 项目特定实践

### 图片资源管理

- **图片资源引用 (强制)**: 为规避 Webpack `url-loader` 可能导致的图片资源损坏问题，所有静态图片资源（如 `.png`, `.jpg`）**严禁使用 `import` 方式引入**。所有图片必须通过**字符串路径**的方式在组件中引用。
  - **✅ 正确做法 (字符串路径)**:
    ```tsx
    const myLogo = "/assets/logo.png";
    <Image src={myLogo} />;
    ```
  - **❌ 错误做法 (模块导入)**:
    ```tsx
    import myLogo from "@/assets/logo.png";
    <Image src={myLogo} />;
    ```

## 🛡️ 代码质量与常见陷阱

为了保持代码库的整洁和高质量，本项目执行严格的静态代码检查。以下是在本次代码库大规模审查和修复过程中总结的常见问题及其解决方案，所有开发者都应熟悉并遵守。

### ESLint 常见错误修复指南

1.  **未使用的变量 (`no-unused-vars`)**
    - **问题**: 函数参数或 `catch` 块中的 `error` 对象被声明但从未使用。
    - **解决方案**:
      - 对于确实不需要使用的变量（尤其是 `catch` 块中的 `error`），请**直接移除变量声明**，改为 `catch {}`。
      - 如果因为函数签名等原因必须保留参数，请在变量名前添加下划线前缀，例如 `_unusedParam`。我们的 ESLint 配置 (`varsIgnorePattern: "^_"`) 会自动忽略以下划线开头的变量。

2.  **不必要的 `try/catch` 包装 (`no-useless-catch`)**
    - **问题**: `catch` 块中唯一的逻辑就是 `throw error;`。这种包装是多余的，它既没有处理错误，也没有添加任何上下文信息。
    - **解决方案**: **直接移除 `try/catch` 语句**，让错误自然地向上冒泡。

3.  **空接口定义 (`no-empty-object-type`)**
    - **问题**: 定义了一个空的接口，例如 `interface MyProps {}`，或者一个只继承了父接口但没有添加任何新属性的接口，例如 `interface MyProps extends BaseProps {}`。
    - **解决方案**:
      - 如果接口确实不需要任何属性，请考虑是否真的需要这个接口。
      - 对于继承而来的空接口，应使用类型别名（`type`）代替，例如 `type MyProps = BaseProps;`。

4.  **`switch` 中的词法声明 (`no-case-declarations`)**
    - **问题**: 在 `switch` 语句的 `case` 子句中直接声明变量（如 `let`, `const`, `function`, `class`）。
    - **解决方案**: 将每个 `case` 子句的内容用花括号 `{}` 包裹起来，为其创建一个块级作用域。

5.  **禁止使用 `require` (`no-require-imports`)**
    - **问题**: 项目中混用了 `require` (CommonJS) 和 `import` (ESM) 两种模块导入方式。
    - **解决方案**: **统一使用 `import` 语句**。对于需要动态导入的场景，请使用 `await import()`。
