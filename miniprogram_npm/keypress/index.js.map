{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * This module offers the internal \"keypress\" functionality from node-core's\n * `readline` module, for your own programs and modules to use.\n *\n * Usage:\n *\n *   require('keypress')(process.stdin);\n *\n *   process.stdin.on('keypress', function (ch, key) {\n *     console.log(ch, key);\n *     if (key.ctrl && key.name == 'c') {\n *       process.stdin.pause();\n *     }\n *   });\n *   proces.stdin.resume();\n */\nvar exports = module.exports = keypress;\n\nexports.enableMouse = function (stream) {\n  stream.write('\\x1b' +'[?1000h')\n}\n\nexports.disableMouse = function (stream) {\n  stream.write('\\x1b' +'[?1000l')\n}\n\n\n/**\n * accepts a readable Stream instance and makes it emit \"keypress\" events\n */\n\nfunction keypress(stream) {\n  if (isEmittingKeypress(stream)) return;\n  stream._emitKeypress = true;\n\n  function onData(b) {\n    if (stream.listeners('keypress').length > 0) {\n      emitKey(stream, b);\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener('data', onData);\n      stream.on('newListener', onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event == 'keypress') {\n      stream.on('data', onData);\n      stream.removeListener('newListener', onNewListener);\n    }\n  }\n\n  if (stream.listeners('keypress').length > 0) {\n    stream.on('data', onData);\n  } else {\n    stream.on('newListener', onNewListener);\n  }\n}\n\n/**\n * Returns `true` if the stream is already emitting \"keypress\" events.\n * `false` otherwise.\n */\n\nfunction isEmittingKeypress(stream) {\n  var rtn = stream._emitKeypress;\n  if (!rtn) {\n    // hack: check for the v0.6.x \"data\" event\n    stream.listeners('data').forEach(function (l) {\n      if (l.name == 'onData' && /emitKey/.test(l.toString())) {\n        rtn = true;\n        stream._emitKeypress = true;\n      }\n    });\n  }\n  if (!rtn) {\n    // hack: check for the v0.6.x \"newListener\" event\n    stream.listeners('newListener').forEach(function (l) {\n      if (l.name == 'onNewListener' && /keypress/.test(l.toString())) {\n        rtn = true;\n        stream._emitKeypress = true;\n      }\n    });\n  }\n  return rtn;\n}\n\n\n/*\n  Some patterns seen in terminal key escape codes, derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\n\n// Regexes used for ansi escape code splitting\nvar metaKeyCodeRe = /^(?:\\x1b)([a-zA-Z0-9])$/;\nvar functionKeyCodeRe =\n    /^(?:\\x1b+)(O|N|\\[|\\[\\[)(?:(\\d+)(?:;(\\d+))?([~^$])|(?:1;)?(\\d+)?([a-zA-Z]))/;\n\nfunction emitKey(stream, s) {\n  var ch,\n      key = {\n        name: undefined,\n        ctrl: false,\n        meta: false,\n        shift: false\n      },\n      parts;\n\n  if (Buffer.isBuffer(s)) {\n    if (s[0] > 127 && s[1] === undefined) {\n      s[0] -= 128;\n      s = '\\x1b' + s.toString(stream.encoding || 'utf-8');\n    } else {\n      s = s.toString(stream.encoding || 'utf-8');\n    }\n  }\n\n  key.sequence = s;\n\n  if (s === '\\r' || s === '\\n') {\n    // enter\n    key.name = 'enter';\n\n  } else if (s === '\\t') {\n    // tab\n    key.name = 'tab';\n\n  } else if (s === '\\b' || s === '\\x7f' ||\n             s === '\\x1b\\x7f' || s === '\\x1b\\b') {\n    // backspace or ctrl+h\n    key.name = 'backspace';\n    key.meta = (s.charAt(0) === '\\x1b');\n\n  } else if (s === '\\x1b' || s === '\\x1b\\x1b') {\n    // escape key\n    key.name = 'escape';\n    key.meta = (s.length === 2);\n\n  } else if (s === ' ' || s === '\\x1b ') {\n    key.name = 'space';\n    key.meta = (s.length === 2);\n\n  } else if (s <= '\\x1a') {\n    // ctrl+letter\n    key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);\n    key.ctrl = true;\n\n  } else if (s.length === 1 && s >= 'a' && s <= 'z') {\n    // lowercase letter\n    key.name = s;\n\n  } else if (s.length === 1 && s >= 'A' && s <= 'Z') {\n    // shift+letter\n    key.name = s.toLowerCase();\n    key.shift = true;\n\n  } else if (parts = metaKeyCodeRe.exec(s)) {\n    // meta+character key\n    key.name = parts[1].toLowerCase();\n    key.meta = true;\n    key.shift = /^[A-Z]$/.test(parts[1]);\n\n  } else if (parts = functionKeyCodeRe.exec(s)) {\n    // ansi escape sequence\n\n    // reassemble the key code leaving out leading \\x1b's,\n    // the modifier key bitflag and any meaningless \"1;\" sequence\n    var code = (parts[1] || '') + (parts[2] || '') +\n               (parts[4] || '') + (parts[6] || ''),\n        modifier = (parts[3] || parts[5] || 1) - 1;\n\n    // Parse the key modifier\n    key.ctrl = !!(modifier & 4);\n    key.meta = !!(modifier & 10);\n    key.shift = !!(modifier & 1);\n    key.code = code;\n\n    // Parse the key itself\n    switch (code) {\n      /* xterm/gnome ESC O letter */\n      case 'OP': key.name = 'f1'; break;\n      case 'OQ': key.name = 'f2'; break;\n      case 'OR': key.name = 'f3'; break;\n      case 'OS': key.name = 'f4'; break;\n\n      /* xterm/rxvt ESC [ number ~ */\n      case '[11~': key.name = 'f1'; break;\n      case '[12~': key.name = 'f2'; break;\n      case '[13~': key.name = 'f3'; break;\n      case '[14~': key.name = 'f4'; break;\n\n      /* from Cygwin and used in libuv */\n      case '[[A': key.name = 'f1'; break;\n      case '[[B': key.name = 'f2'; break;\n      case '[[C': key.name = 'f3'; break;\n      case '[[D': key.name = 'f4'; break;\n      case '[[E': key.name = 'f5'; break;\n\n      /* common */\n      case '[15~': key.name = 'f5'; break;\n      case '[17~': key.name = 'f6'; break;\n      case '[18~': key.name = 'f7'; break;\n      case '[19~': key.name = 'f8'; break;\n      case '[20~': key.name = 'f9'; break;\n      case '[21~': key.name = 'f10'; break;\n      case '[23~': key.name = 'f11'; break;\n      case '[24~': key.name = 'f12'; break;\n\n      /* xterm ESC [ letter */\n      case '[A': key.name = 'up'; break;\n      case '[B': key.name = 'down'; break;\n      case '[C': key.name = 'right'; break;\n      case '[D': key.name = 'left'; break;\n      case '[E': key.name = 'clear'; break;\n      case '[F': key.name = 'end'; break;\n      case '[H': key.name = 'home'; break;\n\n      /* xterm/gnome ESC O letter */\n      case 'OA': key.name = 'up'; break;\n      case 'OB': key.name = 'down'; break;\n      case 'OC': key.name = 'right'; break;\n      case 'OD': key.name = 'left'; break;\n      case 'OE': key.name = 'clear'; break;\n      case 'OF': key.name = 'end'; break;\n      case 'OH': key.name = 'home'; break;\n\n      /* xterm/rxvt ESC [ number ~ */\n      case '[1~': key.name = 'home'; break;\n      case '[2~': key.name = 'insert'; break;\n      case '[3~': key.name = 'delete'; break;\n      case '[4~': key.name = 'end'; break;\n      case '[5~': key.name = 'pageup'; break;\n      case '[6~': key.name = 'pagedown'; break;\n\n      /* putty */\n      case '[[5~': key.name = 'pageup'; break;\n      case '[[6~': key.name = 'pagedown'; break;\n\n      /* rxvt */\n      case '[7~': key.name = 'home'; break;\n      case '[8~': key.name = 'end'; break;\n\n      /* rxvt keys with modifiers */\n      case '[a': key.name = 'up'; key.shift = true; break;\n      case '[b': key.name = 'down'; key.shift = true; break;\n      case '[c': key.name = 'right'; key.shift = true; break;\n      case '[d': key.name = 'left'; key.shift = true; break;\n      case '[e': key.name = 'clear'; key.shift = true; break;\n\n      case '[2$': key.name = 'insert'; key.shift = true; break;\n      case '[3$': key.name = 'delete'; key.shift = true; break;\n      case '[5$': key.name = 'pageup'; key.shift = true; break;\n      case '[6$': key.name = 'pagedown'; key.shift = true; break;\n      case '[7$': key.name = 'home'; key.shift = true; break;\n      case '[8$': key.name = 'end'; key.shift = true; break;\n\n      case 'Oa': key.name = 'up'; key.ctrl = true; break;\n      case 'Ob': key.name = 'down'; key.ctrl = true; break;\n      case 'Oc': key.name = 'right'; key.ctrl = true; break;\n      case 'Od': key.name = 'left'; key.ctrl = true; break;\n      case 'Oe': key.name = 'clear'; key.ctrl = true; break;\n\n      case '[2^': key.name = 'insert'; key.ctrl = true; break;\n      case '[3^': key.name = 'delete'; key.ctrl = true; break;\n      case '[5^': key.name = 'pageup'; key.ctrl = true; break;\n      case '[6^': key.name = 'pagedown'; key.ctrl = true; break;\n      case '[7^': key.name = 'home'; key.ctrl = true; break;\n      case '[8^': key.name = 'end'; key.ctrl = true; break;\n\n      /* misc. */\n      case '[Z': key.name = 'tab'; key.shift = true; break;\n      default: key.name = 'undefined'; break;\n\n    }\n  } else if (s.length > 1 && s[0] !== '\\x1b') {\n    // Got a longer-than-one string of characters.\n    // Probably a paste, since it wasn't a control sequence.\n    Array.prototype.forEach.call(s, function(c) {\n      emitKey(stream, c);\n    });\n    return;\n  }\n\n  if (key.code == '[M') {\n    key.name = 'mouse';\n    var s = key.sequence;\n    var b = s.charCodeAt(3);\n    key.x = s.charCodeAt(4) - 32;\n    key.y = s.charCodeAt(5) - 32;\n\n    key.scroll = 0;\n\n    key.ctrl  = !!(1<<4 & b);\n    key.meta  = !!(1<<3 & b);\n    key.shift = !!(1<<2 & b);\n\n    key.release = (3 & b) === 3;\n\n    if (1<<6 & b) { //scroll\n      key.scroll = 1 & b ? 1 : -1;\n    }\n\n    if (!key.release && !key.scroll) {\n      key.button = b & 3;\n    }\n  }\n\n  // Don't emit a key if no name was found\n  if (key.name === undefined) {\n    key = undefined;\n  }\n\n  if (s.length === 1) {\n    ch = s;\n  }\n\n  if (key && key.name == 'mouse') {\n    stream.emit('mousepress', key)\n  } else if (key || ch) {\n    stream.emit('keypress', ch, key);\n  }\n}\n"]}