## 环境

win11 powershell or wsl ubuntu22.04

后端api文档参考kjxwr6px14.apifox.cn，或者cursor解析的docs @blockbondOpenapi
或者请求https://nkuwiki.com/openapi.json

代码质量检查: npm run lint > lint_errors.txt

禁止自己运行npm run等命令

taro组件文档参考docs/TARO_COMPONENTS_GUIDE.md

### 后端提供两种认证方式

必须认证接口：只有登录用户可访问，有token

可选认证接口，无需登录，无token，通过请求头的 x-tenant-id 指定租户

### 测试账号与令牌（仅本地开发）

- nankai 租户（tenant_id = f6303899-a51a-460a-9cd8-fe35609151eb）
  - username: nankai_user
  - password: Test@1234
  - token (bearer): eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwidGVuYW50X2lkIjoiZjYzMDM4OTktYTUxYS00NjBhLTljZDgtZmUzNTYwOTE1MWViIiwibmlja25hbWUiOiJuYW5rYWlfdXNlciIsInJvbGVzIjpbInVzZXIiXSwiZXhwIjoxNzU4MDA1MTQ5fQ.NWRyI5bQRWyRwrV5oPozoI4R9lrGVk6NANFlN20HutE

注：以上 token 为当前运行时生成，会随时间过期，过期后请通过 `/api/v1/auth/login` 重新获取。

## Wiki 项目规范

欢迎来到 Wiki 项目！为了保证代码质量和开发效率，我们将所有的开发规范、最佳实践和工作流都进行了文档化。

原有的 `.cursorrules` 文件已被模块化拆分，以提高可读性和可维护性。请根据您关心的主题，查阅以下位于 `.cursor/rules/` 目录下的具体规范文档：

- **[项目总览](./.cursor/rules/overview.mdc)**
  - 了解项目目标、技术栈、目录结构和核心功能模块。
- **[Linting 与代码格式化](./.cursor/rules/linting.mdc)**
  - 学习项目的 ESLint, Prettier 和 Stylelint 配置，确保代码风格统一。
- **[编码与UI规范](./.cursor/rules/style-guide.mdc)**
  - 遵循统一的命名、代码风格、颜色管理及组件开发规范。
- **[开发实践与工作流](./.cursor/rules/practices.mdc)**
  - 查看性能优化、布局规范、API 对接、状态管理、Git 工作流等核心实践。

**请在开始开发前，务必熟悉与您工作内容相关的规范文档。**
**禁止自己运行npm run dev编译，你只需要改代码**

---
## 核心规范摘要

### 项目总览 (overview.mdc)
- **目标**: 使用 Taro 框架构建高质量的微信小程序。
- **技术栈**: Taro 4.x, React, Redux, TypeScript, SCSS。
- **核心依赖**: 项目依赖 `@tarojs/plugin-framework-react`, `@tarojs/plugin-platform-weapp`, `babel-preset-taro` 等核心插件。
- **目录结构**: 遵循官方推荐，对 `src` 目录进行精细化划分 (`assets`, `components`, `constants`, `pages`, `services`, `store`, `types`)。
- **核心模块**: 首页、探索、发现、我的。

### 编码规范 (style-guide.mdc)
- **代码质量 (强制)**: 所有代码必须完全符合 ESLint 和 TSLint 的所有规则要求，不得有任何 linter 错误或警告。
  - **ESLint 规则**: 必须遵守项目配置的所有 ESLint 规则，包括但不限于代码风格、潜在错误检测、最佳实践等。
  - **TSLint 规则**: 必须遵守项目配置的所有 TSLint 规则，包括类型检查、代码质量、命名规范等。
  - **零容忍原则**: 任何 linter 错误或警告都必须立即修复，不得提交包含 linter 问题的代码。
  - **提交前检查**: 使用 `npm run lint` 或 `npm run lint:fix` 命令进行全面检查，确保所有文件都通过 linter 验证。
  - **持续集成**: CI/CD 流水线会自动运行 linter 检查，任何违反规则的代码将阻止合并。
  - **责任划分**: 开发者负责确保自己提交的代码通过所有 linter 检查，代码审查时也需要重点关注 linter 问题。

- **🔴 ESLint 错误预防规则 (强制性)**:
  - **未使用变量**: 所有未使用的变量必须以下划线 `_` 开头，如 `_unusedVar`，禁止使用 `// eslint-disable-next-line` 注释。
  - **未使用导入**: 移除所有未使用的 import 语句，禁止保留无用的导入。
  - **导入顺序**: 绝对导入必须在相对导入之前，第三方库导入在项目内部导入之前。
  - **Console 语句**: 禁止在生产代码中使用 `console.log`、`console.error` 等，除非是调试代码且添加了注释说明。
  - **变量遮挡**: 禁止在同一作用域内声明同名变量，使用不同的命名来避免遮挡。
  - **React Hook 依赖**: 所有 useEffect、useCallback 等 Hook 必须包含正确的依赖数组，禁止遗漏必要依赖。
  - **类型定义文件**: API 类型定义文件中的枚举值即使当前未使用也必须保留（添加 `/* eslint-disable no-unused-vars */`），因为它们定义了 API 的可能取值。
- **命名**: 目录和非组件文件用 `kebab-case`，React 组件用 `PascalCase`，变量和函数用 `camelCase`，常量用 `UPPER_SNAKE_CASE`。
- **TypeScript**: 开启 `strict` 模式，明确类型定义，优先使用 `interface`。
- **React**: 全面使用函数式组件和 Hooks，使用 `useMemo`/`useCallback` 优化性能，自定义 Hooks 以 `use` 开头。
- **SCSS (强制)**: 必须使用 `*.module.scss`，全局样式写入 `src/app.scss`，使用 `px` 单位（Taro会自动转换为rpx）。
- **颜色管理 (强制)**: 严禁硬编码颜色。SCSS 中使用 `src/styles/variables.scss` 的变量，TS 中使用 `src/constants/colors.ts` 的常量。
- **组件开发**: 优先使用微信原生组件库，其次才是Taro UI，自定义组件放在 `src/components`，样式使用 `.module.scss`。
- **UI/UX**: 设计风格追求简洁、卡片式布局，多采用圆角、留白和阴影。

### 最佳实践 (practices.mdc)
- **性能优化**: 积极采用分包加载、图片压缩、虚拟列表等技术，并使用 `webpack-bundle-analyzer` 分析包体积。
- **布局 (强制)**: 所有页面必须使用 `<CustomHeader>` + `<ScrollView>` 的"防内容遮挡"顶级布局结构。
- **安全区域 (强制)**: 禁止在自定义导航栏右上角区域放置任何可交互控件。
- **图标 (强制)**: 所有图标必须是本地资源，存放于 `src/assets`。推荐从 [Iconify Solar](https://api.iconify.design/solar/) 下载 `SVG` 格式图标
- **图片资源引用 (强制)**: 为规避 Webpack `url-loader` 可能导致的图片资源损坏（渲染为色块）问题，所有静态图片资源（如 `.png`, `.jpg`）**严禁使用 `import` 方式引入**。所有图片必须通过**字符串路径**的方式在组件中引用。
    - **✅ 正确做法 (字符串路径)**:
      ```tsx
      // 直接定义字符串路径
      const myLogo = '/assets/logo.png';

      // 在组件中使用
      <Image src={myLogo} />
      ```
    - **❌ 错误做法 (模块导入)**:
      ```tsx
      // 严禁使用 import 引入图片
      import myLogo from '@/assets/logo.png';

      <Image src={myLogo} />
      ```
    此规则旨在确保图片被 `Taro` 的 `copy` 机制正确处理，并由小程序本身在运行时进行加载，从而绕开编译阶段潜在的 `loader` 问题。
- **API 对接工作流 (强制)**: 不需要添加api/v1/前缀已经在api.ts全局添加严格遵循"读文档 -> 定义类型 -> 创建 Service -> 创建 Thunk -> 组件使用"的五步流程。
- **状态管理**: 选用 Redux Toolkit (RTK)，在 `src/store/slices` 中组织 `slice` 文件。接口请求通过 `createAsyncThunk` 更新 store，使用 `redux-persist` 持久化关键数据。
- **Git 工作流**: 采用 `Git Flow` 模型，Commit Message 遵循 `Angular` 规范（推荐使用 `commitizen`），并使用 `Husky` + `lint-staged` 保证代码质量。
- **代码测试**: 使用 `Jest` 和 `@tarojs/test-utils-react` 进行单元测试，测试文件以 `.spec.ts` 结尾。
- **核心重构任务**: 参考 `nkuwiki-app/` 项目，将 Next.js 实现（HTML 标签, Tailwind, `lucide-react`）翻译为 Taro 规范（Taro 组件, SCSS, 本地 SVG）。

- **🛡️ 代码质量保障 (强制性)**:
  - **变量清理**: 编写代码时立即检查并清理未使用的变量，养成良好的编码习惯。
  - **导入管理**: 每次修改代码后检查 import 语句，移除未使用的导入，保持导入顺序。
  - **Hook 依赖**: 使用 React Hook 时仔细检查依赖数组，确保包含所有必要的依赖项。
  - **错误处理**: catch 块中的 error 参数必须重命名为 `_error` 以避免遮挡问题。
  - **调试代码**: 添加 console 语句时必须添加注释说明，并在提交前移除或注释掉。
  - **类型定义**: API 类型文件中的枚举即使未使用也要保留，它们定义了API的可能值。

### 🚨 SVG 图标尺寸问题排查指南

在开发中，可能会遇到 SVG 图标的尺寸无法通过 SCSS 的 `width` 和 `height` 属性进行有效控制的问题。当图标显示过大时，请遵循以下步骤进行排查：

1.  **第一步：检查 SVG 文件源码**
    -   打开表现异常的 `.svg` 文件。
    -   检查其根 `<svg>` 标签是否包含 `width="..."` 和 `height="..."` 属性。
    -   **解决方案**：如果存在这些属性，请**务必将其移除**。这些内联属性的优先级高于外部样式表，是导致问题的主要原因。
    
    ```diff
    - <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24">
    + <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    ```

2.  **第二步：使用内联样式强制覆盖**
    -   如果移除 SVG 内部属性后问题依旧存在，这可能意味着有其他更复杂的样式冲突。
    -   **最终解决方案**：为了确保样式被强制应用，可以直接在 Taro 的 `<Image>` 组件上使用**内联样式（inline style）**。这是优先级最高的样式定义方式。
    
    ```tsx
    import myIcon from '@/assets/my-icon.svg';

    // ...

    <Image 
      src={myIcon} 
      className={styles.iconClass} // 外部样式类可能失效
      style={{ width: '18px', height: '18px' }} // 使用内联样式强制定义尺寸
    />
    ```

遵循以上两步，通常可以解决绝大部分的 SVG 图标尺寸问题，确保 UI 的一致性和可控性。

---

## 🚫 ESLint 错误预防指南

### 常见错误模式及解决方案

#### 1. 未使用变量错误
```typescript
// ❌ 错误：未使用的变量
const unusedVar = 'test';

// ✅ 正确：添加下划线前缀
const _unusedVar = 'test';

// ❌ 错误：未使用的函数参数
function testFunction(param1: string, param2: number) {
  console.log(param1); // 只使用了 param1
}

// ✅ 正确：未使用的参数加下划线
function testFunction(param1: string, _param2: number) {
  console.log(param1);
}
```

#### 2. 导入顺序错误
```typescript
// ❌ 错误：相对导入在绝对导入之前
import styles from './component.module.scss';
import { View } from '@tarojs/components';
import { useState } from 'react';

// ✅ 正确：绝对导入在前，相对导入在后
import { useState } from 'react';
import { View } from '@tarojs/components';

import styles from './component.module.scss';
```

#### 3. Console 语句错误
```typescript
// ❌ 错误：生产代码中的 console 语句
console.log('Debug info');

// ✅ 正确：注释掉或移除
// console.log('Debug info');
```

#### 4. React Hook 依赖错误
```typescript
// ❌ 错误：遗漏依赖
useEffect(() => {
  console.log(count);
}, []); // 缺少 count 依赖

// ✅ 正确：包含所有必要依赖
useEffect(() => {
  console.log(count);
}, [count]);
```

#### 5. 变量遮挡错误
```typescript
// ❌ 错误：catch 中的 error 与外部变量同名
const error = 'some error';
try {
  // some code
} catch (error) { // 遮挡了外部的 error 变量
  console.log(error);
}

// ✅ 正确：重命名参数
const error = 'some error';
try {
  // some code
} catch (_error) { // 使用下划线前缀
  console.log(_error);
}
```

#### 6. 未使用的导入错误
```typescript
// ❌ 错误：导入但未使用
import { unusedFunction } from './utils';

// ✅ 正确：移除未使用的导入
// 如果确实需要保留，添加注释说明原因
// import { unusedFunction } from './utils'; // 用于未来功能
```

### 🔧 快速修复命令

```bash
# 检查所有 lint 错误
npm run lint

# 自动修复可自动修复的错误
npm run lint:fix

# 检查特定文件
npm run lint src/pages/some-page/index.tsx
```

### 📋 提交前检查清单

- [ ] 运行 `npm run lint` 检查无错误
- [ ] 移除所有未使用的 import 语句
- [ ] 未使用的变量添加 `_` 前缀
- [ ] 检查导入顺序是否正确
- [ ] 移除或注释调试用的 console 语句
- [ ] 检查 React Hook 依赖数组是否完整
- [ ] 确保无变量遮挡问题

### ⚠️ 特殊情况处理

- **类型定义文件**: API 类型文件中的枚举即使未使用也要保留（添加 `/* eslint-disable no-unused-vars */`）
- **第三方库类型**: 对于第三方库的类型定义，优先使用官方类型定义而不是禁用规则
- **遗留代码**: 如需保留暂时未使用的代码，添加清晰的注释说明原因