## 环境

win11 powershell or wsl ubuntu22.04

后端api文档参考kjxwr6px14.apifox.cn，或者cursor解析的docs @blockbondOpenapi
或者请求https://nkuwiki.com/openapi.json

代码质量检查: `npm run lint:all`

禁止自己运行npm run等命令

taro组件文档参考docs/TARO_COMPONENTS_GUIDE.md

### 后端提供两种认证方式

必须认证接口：只有登录用户可访问，有token

可选认证接口，无需登录，无token，通过请求头的 x-tenant-id 指定租户

### 测试账号与令牌（仅本地开发）

- nankai 租户（tenant_id = f6303899-a51a-460a-9cd8-fe35609151eb）
  - username: nankai_user
  - password: Test@1234
  - token (bearer): eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwidGVuYW50X2lkIjoiZjYzMDM4OTktYTUxYS00NjBhLTljZDgtZmUzNTYwOTE1MWViIiwibmlja25hbWUiOiJuYW5rYWlfdXNlciIsInJvbGVzIjpbInVzZXIiXSwiZXhwIjoxNzU4MDA1MTQ5fQ.NWRyI5bQRWyRwrV5oPozoI4R9lrGVk6NANFlN20HutE

注：以上 token 为当前运行时生成，会随时间过期，过期后请通过 `/api/v1/auth/login` 重新获取。

## Wiki 项目规范

欢迎来到 Wiki 项目！为了保证代码质量和开发效率，我们将所有的开发规范、最佳实践和工作流都进行了文档化。

项目规范已被模块化拆分，以提高可读性和可维护性。请根据您关心的主题，查阅以下位于 `.cursor/rules/` 目录下的具体规范文档：

- **[项目总览](./.cursor/rules/overview.mdc)**
  - 了解项目目标、技术栈、目录结构和核心功能模块。
- **[Linting 与代码格式化](./.cursor/rules/linting.mdc)**
  - **(新!)** 学习项目的 ESLint, Prettier 和 Stylelint 配置，确保代码风格统一。
- **[编码与UI规范](./.cursor/rules/style-guide.mdc)**
  - 遵循统一的命名、代码风格、颜色管理及组件开发规范。
- **[开发实践与工作流](./.cursor/rules/practices.mdc)**
  - 查看性能优化、布局规范、API 对接、状态管理、Git 工作流等核心实践。

**请在开始开发前，务必熟悉与您工作内容相关的规范文档。**
**禁止自己运行npm run dev编译，你只需要改代码**

---
## 核心规范摘要

### 项目总览 (overview.mdc)
- **目标**: 使用 Taro 框架构建高质量的微信小程序。
- **技术栈**: Taro 4.x, React, Redux, TypeScript, SCSS。
- **目录结构**: 遵循官方推荐，对 `src` 目录进行精细化划分。

### Linting 与代码格式化 (linting.mdc)
- **目标**: 通过 Prettier, ESLint, Stylelint 建立三位一体的代码质量保障体系。
- **Prettier**: 格式化唯一权威，负责代码风格。
- **ESLint**: 专注于 JS/TS 代码质量，检查逻辑错误和最佳实践，强制严格的导入顺序和 Hooks 依赖。
- **Stylelint**: 专注于 SCSS 代码质量，兼容小程序 `rpx` 单位，执行 SCSS 最佳实践。

### 编码规范 (style-guide.mdc)
- **代码质量 (强制)**: 所有代码必须完全符合 `linting.mdc` 中定义的规范，不得有任何 linter 错误或警告。
- **命名**: 目录和非组件文件用 `kebab-case`，React 组件用 `PascalCase`，变量和函数用 `camelCase`，常量用 `UPPER_SNAKE_CASE`。
- **TypeScript**: 开启 `strict` 模式，明确类型定义。
- **React**: 全面使用函数式组件和 Hooks。
- **SCSS (强制)**: 必须使用 `*.module.scss`，严禁硬编码颜色。

### 最佳实践 (practices.mdc)
- **性能优化**: 积极采用分包加载、图片压缩、虚拟列表等技术。
- **布局 (强制)**: 所有页面必须使用 `<CustomHeader>` + `<ScrollView>` 的顶级布局结构。
- **图片资源引用 (强制)**: 必须通过字符串路径引用图片，严禁 `import`。
- **API 对接工作流 (强制)**: 严格遵循"定义类型 -> 创建 Service -> 创建 Thunk -> 组件使用"的流程。
- **Git 工作流**: 采用 `Git Flow` 模型，Commit Message 遵循 `Angular` 规范。

### 🚨 SVG 图标尺寸问题排查指南

在开发中，可能会遇到 SVG 图标的尺寸无法通过 SCSS 的 `width` 和 `height` 属性进行有效控制的问题。当图标显示过大时，请遵循以下步骤进行排查：

1.  **第一步：检查 SVG 文件源码**
    -   打开表现异常的 `.svg` 文件。
    -   检查其根 `<svg>` 标签是否包含 `width="..."` 和 `height="..."` 属性。
    -   **解决方案**：如果存在这些属性，请**务必将其移除**。这些内联属性的优先级高于外部样式表，是导致问题的主要原因。
    
    ```diff
    - <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24">
    + <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    ```

2.  **第二步：使用内联样式强制覆盖**
    -   如果移除 SVG 内部属性后问题依旧存在，这可能意味着有其他更复杂的样式冲突。
    -   **最终解决方案**：为了确保样式被强制应用，可以直接在 Taro 的 `<Image>` 组件上使用**内联样式（inline style）**。这是优先级最高的样式定义方式。
    
    ```tsx
    import myIcon from '@/assets/my-icon.svg';

    // ...

    <Image 
      src={myIcon} 
      className={styles.iconClass} // 外部样式类可能失效
      style={{ width: '18px', height: '18px' }} // 使用内联样式强制定义尺寸
    />
    ```

遵循以上两步，通常可以解决绝大部分的 SVG 图标尺寸问题，确保 UI 的一致性和可控性。

---

## 🚫 ESLint 错误预防指南

### 常见错误模式及解决方案

#### 1. 未使用变量错误
```typescript
// ❌ 错误：未使用的变量
const unusedVar = 'test';

// ✅ 正确：添加下划线前缀
const _unusedVar = 'test';

// ❌ 错误：未使用的函数参数
function testFunction(param1: string, param2: number) {
  console.log(param1); // 只使用了 param1
}

// ✅ 正确：未使用的参数加下划线
function testFunction(param1: string, _param2: number) {
  console.log(param1);
}
```

#### 2. 导入顺序错误
```typescript
// ❌ 错误：相对导入在绝对导入之前
import styles from './component.module.scss';
import { View } from '@tarojs/components';
import { useState } from 'react';

// ✅ 正确：绝对导入在前，相对导入在后
import { useState } from 'react';
import { View } from '@tarojs/components';

import styles from './component.module.scss';
```

#### 3. Console 语句错误
```typescript
// ❌ 错误：生产代码中的 console 语句
console.log('Debug info');

// ✅ 正确：注释掉或移除
// console.log('Debug info');
```

#### 4. React Hook 依赖错误
```typescript
// ❌ 错误：遗漏依赖
useEffect(() => {
  console.log(count);
}, []); // 缺少 count 依赖

// ✅ 正确：包含所有必要依赖
useEffect(() => {
  console.log(count);
}, [count]);
```

#### 5. 变量遮挡错误
```typescript
// ❌ 错误：catch 中的 error 与外部变量同名
const error = 'some error';
try {
  // some code
} catch (error) { // 遮挡了外部的 error 变量
  console.log(error);
}

// ✅ 正确：重命名参数
const error = 'some error';
try {
  // some code
} catch (_error) { // 使用下划线前缀
  console.log(_error);
}
```

#### 6. 未使用的导入错误
```typescript
// ❌ 错误：导入但未使用
import { unusedFunction } from './utils';

// ✅ 正确：移除未使用的导入
// 如果确实需要保留，添加注释说明原因
// import { unusedFunction } from './utils'; // 用于未来功能
```

### 🔧 快速修复命令

```bash
# 检查所有 lint 错误
npm run lint

# 自动修复可自动修复的错误
npm run lint:fix

# 检查特定文件
npm run lint src/pages/some-page/index.tsx
```

### 📋 提交前检查清单

- [ ] 运行 `npm run lint` 检查无错误
- [ ] 移除所有未使用的 import 语句
- [ ] 未使用的变量添加 `_` 前缀
- [ ] 检查导入顺序是否正确
- [ ] 移除或注释调试用的 console 语句
- [ ] 检查 React Hook 依赖数组是否完整
- [ ] 确保无变量遮挡问题

### ⚠️ 特殊情况处理

- **类型定义文件**: API 类型文件中的枚举即使未使用也要保留（添加 `/* eslint-disable no-unused-vars */`）
- **第三方库类型**: 对于第三方库的类型定义，优先使用官方类型定义而不是禁用规则
- **遗留代码**: 如需保留暂时未使用的代码，添加清晰的注释说明原因